<p><link rel="stylesheet" href="http://jasonm23.github.io/markdown-css-themes/swiss.css"></p>
<h1 id="-13-angularjs-rest-https-mooxe000-github-io-angularjstutorial_cn-"><a href="https://Mooxe000.github.io/AngularjsTutorial_cn">13. AngularJS REST和定制服务</a></h1>
<p>在这一步中，我们会改进我们APP获取数据的方式。</p>
<p>请重置工作目录：</p>
<pre><code>git checkout -f step-11
</code></pre><p>对我们应用所做的最后一个改进就是定义一个代表<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</a>客户端的定制服务。有了这个客户端我们可以用一种更简单的方式来发送XHR请求，而不用去关心更底层的<a href="http://code.angularjs.org/1.1.0/docs/api/ng.$http">$http</a>服务（API、HTTP方法和URL）。</p>
<p>步骤9和步骤10之间最重要的不同在下面列出。你可以在<a href="https://github.com/angular/angular-phonecat/compare/step-10...step-11">GitHub</a>里看到完整的差别。</p>
<h3 id="-">模板</h3>
<p>定制的服务被定义在<strong>app/js/services</strong>，所以我们需要在布局模板中引入这个文件。另外，我们也要加载<strong>angularjs-resource.js</strong>这个文件，它包含了<code>ngResource</code>模块以及其中的<code>$resource</code>服务，我们一会就会用到它们：</p>
<p><strong>app/index.html</strong></p>
<pre><code>...
  &lt;script src=&quot;js/services.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;lib/angular/angular-resource.js&quot;&gt;&lt;/script&gt;
...
</code></pre><h3 id="-">服务</h3>
<p><strong>app/js/services.js</strong></p>
<pre><code>angular.module(&#39;phonecatServices&#39;, [&#39;ngResource&#39;]).
    factory(&#39;Phone&#39;, function($resource){
      return $resource(&#39;phones/:phoneId.json&#39;, {}, {
        query: {method:&#39;GET&#39;, params:{phoneId:&#39;phones&#39;}, isArray:true}
      });
    });
</code></pre><p>我们使用模块API通过一个工厂方法注册了一个定制服务。我们传入服务的名字<code>Phone</code>和工厂函数。工厂函数和控制器构造函数差不多，它们都通过函数参数声明依赖服务。Phone服务声明了它依赖于<code>$resource</code>服务。</p>
<p><a href="http://code.angularjs.org/1.1.0/docs/api/ngResource.$resource">$resource</a>服务使得用短短的几行代码就可以创建一个<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</a>客户端。我们的应用使用这个客户端来代替底层的<a href="http://code.angularjs.org/1.1.0/docs/api/ng.$http">$http</a>服务。</p>
<p><strong>app/js/app.js</strong></p>
<pre><code>...
angular.module(&#39;phonecat&#39;, [&#39;phonecatFilters&#39;, &#39;phonecatServices&#39;]).
...
</code></pre><p>我们需要把<code>phonecatServices</code>添加到<code>phonecat</code>的依赖数组里。</p>
<h3 id="-">控制器</h3>
<p>通过重构掉底层的<a href="http://code.angularjs.org/1.1.0/docs/api/ng.$http">$http</a>服务，把它放在一个新的服务<code>Phone</code>中，我们可以大大简化子控制器（<code>PhoneListCtrl</code>和<code>PhoneDetailCtrl</code>）。AngularJS的<a href="http://code.angularjs.org/1.1.0/docs/api/ngResource.$resource">$resource</a>相比于<code>$http</code>更加适合于与RESTful数据源交互。而且现在我们更容易理解控制器这些代码在干什么了。</p>
<p><strong>app/js/controllers.js</strong></p>
<pre><code>...

function PhoneListCtrl($scope, Phone) {
  $scope.phones = Phone.query();
  $scope.orderProp = &#39;age&#39;;
}

//PhoneListCtrl.$inject = [&#39;$scope&#39;, &#39;Phone&#39;];



function PhoneDetailCtrl($scope, $routeParams, Phone) {
  $scope.phone = Phone.get({phoneId: $routeParams.phoneId}, function(phone) {
    $scope.mainImageUrl = phone.images[0];
  });

  $scope.setImage = function(imageUrl) {
    $scope.mainImageUrl = imageUrl;
  }
}

//PhoneDetailCtrl.$inject = [&#39;$scope&#39;, &#39;$routeParams&#39;, &#39;Phone&#39;];
</code></pre><p>注意到，在<code>PhoneListCtrl</code>里我们把：</p>
<pre><code>$http.get(&#39;phones/phones.json&#39;).success(function(data) {
  $scope.phones = data;
});
</code></pre><p>换成了：</p>
<pre><code>$scope.phones = Phone.query();
</code></pre><p>我们通过这条简单的语句来查询所有的手机。</p>
<p>另一个非常需要注意的是，在上面的代码里面，当调用Phone服务的方法是我们并没有传递任何回调函数。尽管这看起来结果是同步返回的，其实根本就不是。被同步返回的是一个“future”——一个对象，当XHR相应返回的时候会填充进数据。鉴于AngularJS的数据绑定，我们可以使用future并且把它绑定到我们的模板上。然后，当数据到达时，我们的视图会自动更新。</p>
<p>有的时候，单单依赖future对象和数据绑定不足以满足我们的需求，所以在这些情况下，我们需要添加一个回调函数来处理服务器的响应。<code>PhoneDetailCtrl</code>控制器通过在一个回调函数中设置<code>mainImageUrl</code>就是一个解释。</p>
<h3 id="-">测试</h3>
<p>修改我们的单元测试来验证我们新的服务会发起HTTP请求并且按照预期地处理它们。测试同时也检查了我们的控制器是否与服务正确协作。</p>
<p><a href="http://code.angularjs.org/1.1.0/docs/api/ngResource.$resource">$resource</a>服务通过添加更新和删除资源的方法来增强响应得到的对象。如果我们打算使用<code>toEqual</code>匹配器，我们的测试会失败，因为测试值并不会和响应完全等同。为了解决这个问题，我们需要使用一个最近定义的<code>toEqualData</code><a href="http://pivotal.github.com/jasmine/jsdoc/symbols/jasmine.Matchers.html">Jasmine匹配器</a>。当<code>toEqualData</code>匹配器比较两个对象的时候，它只考虑对象的属性而忽略掉所有的方法。</p>
<p><strong>test/unit/controllersSpec.js：</strong></p>
<pre><code>describe(&#39;PhoneCat controllers&#39;, function() {

  beforeEach(function(){
    this.addMatchers({
      toEqualData: function(expected) {
        return angular.equals(this.actual, expected);
      }
    });
  });

 beforeEach(module(&#39;phonecatServices&#39;));

  describe(&#39;PhoneListCtrl&#39;, function(){
    var scope, ctrl, $httpBackend;

    beforeEach(inject(function(_$httpBackend_, $rootScope, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET(&#39;phones/phones.json&#39;).
          respond([{name: &#39;Nexus S&#39;}, {name: &#39;Motorola DROID&#39;}]);

      scope = $rootScope.$new();
      ctrl = $controller(PhoneListCtrl, {$scope: scope});
    }));

    it(&#39;should create &quot;phones&quot; model with 2 phones fetched from xhr&#39;, function() {
      expect(scope.phones).toEqual([]);
      $httpBackend.flush();

      expect(scope.phones).toEqualData(
          [{name: &#39;Nexus S&#39;}, {name: &#39;Motorola DROID&#39;}]);
    });

    it(&#39;should set the default value of orderProp model&#39;, function() {
      expect(scope.orderProp).toBe(&#39;age&#39;);
    });
  });

  describe(&#39;PhoneDetailCtrl&#39;, function(){
    var scope, $httpBackend, ctrl,
        xyzPhoneData = function() {
          return {
            name: &#39;phone xyz&#39;,
            images: [&#39;image/url1.png&#39;, &#39;image/url2.png&#39;]
          }
        };

    beforeEach(inject(function(_$httpBackend_, $rootScope, $routeParams, $controller) {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET(&#39;phones/xyz.json&#39;).respond(xyzPhoneData());

      $routeParams.phoneId = &#39;xyz&#39;;
      scope = $rootScope.$new();
      ctrl = $controller(PhoneDetailCtrl, {$scope: scope});
    }));

    it(&#39;should fetch phone detail&#39;, function() {
      expect(scope.phone).toEqualData({});
      $httpBackend.flush();

      expect(scope.phone).toEqualData(xyzPhoneData());
    });
  });
});
</code></pre><p>执行<code>./scripts/test.sh</code>运行测试，你应该会看到如下的输出：</p>
<pre><code>Chrome: Runner reset.
....
Total 4 tests (Passed: 4; Fails: 0; Errors: 0) (3.00 ms)
  Chrome 19.0.1084.36 Mac OS: Run 4 tests (Passed: 4; Fails: 0; Errors 0) (3.00 ms)
</code></pre><h2 id="-">总结</h2>
<p>完工！你在相当短的时间内已经创建了一个Web应用。在<a href="http://angularjs.cn/A00f">完结篇</a>里面我们会提起接下来应该干什么。</p>
